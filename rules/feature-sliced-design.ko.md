Feature-Sliced Design (FSD) 아키텍처 방법론 v2.1 (한국어)

> 최신 업데이트: 2025년 05월 06일 19:51

## 1. 레이어 구조
  * 레이어는 Feature-Sliced Design의 조직적 계층 구조의 첫 번째 수준입니다.
  * 레이어의 목적은 코드가 필요로 하는 책임의 양과 앱의 다른 모듈에 대한 의존성에 따라 코드를 분리하는 것입니다.
  * 총 6개의 레이어가 있으며, 가장 높은 책임과 의존성에서 가장 낮은 순으로 정렬됩니다:

### 1-1. App 레이어
  * 역할
    - App 레이어는 Feature-Sliced Design 아키텍처의 최상위 레벨입니다.
    - 애플리케이션 초기화, 부트스트래핑 및 전역 구성을 처리합니다.
    - 애플리케이션을 실행하는 데 필요한 모든 것을 포함합니다.
  * 특성
    - 슬라이스를 포함하지 않습니다 (다른 레이어와 달리)
    - 세그먼트로 직접 구성됩니다
    - 가장 높은 수준의 책임과 의존성을 가집니다
    - 다른 모든 레이어에서 가져올 수 있습니다
    - 다른 레이어는 App 레이어에서 가져올 수 없습니다
  * 주요 세그먼트
    - providers: 전역 프로바이더 및 컨텍스트 설정
    - styles: 전역 스타일링 및 테마 구성
    - routes: 애플리케이션 라우팅 구성
    - entry: 메인 진입점 및 초기화 코드
    - fonts: 일관된 타이포그래피를 위한 전역 폰트 로딩 및 설정

### 1-2. Pages 레이어
  * 역할
    - 사용자가 직접 상호작용하는 애플리케이션의 최상위 페이지 뷰를 나타냅니다
  * 특성
    - 각 페이지는 자체 슬라이스입니다 (예: home, profile, article-read, settings)
    - 다른 페이지를 참조할 수 없습니다 (다른 페이지에서 코드를 가져올 수 없음)
    - 아래 레이어에서만 가져올 수 있습니다 (widgets, features, entities, shared)
    - 위젯, 기능 및 기타 컴포넌트를 결합하여 완전한 페이지를 만듭니다
    - 일반적으로 해당 페이지에 특정한 라우팅 구성을 포함합니다
    - 페이지별 레이아웃, 상태 관리 및 API 상호작용을 포함할 수 있습니다
  * 주요 세그먼트
    - ui: 페이지별 컴포넌트 및 레이아웃
    - api: 페이지별 API 요청
    - model: 페이지별 상태 및 비즈니스 로직
    - lib: 페이지별 헬퍼 함수 및 유틸리티
    - config: 구성 파일 및 기능 플래그

### 1-3. Widgets 레이어
  * 역할
    - 여러 페이지에서 재사용할 수 있는 크고 자급자족적인 UI 블록을 나타냅니다
    - 완전한 사용자 인터페이스 기능을 제공하는 복잡한 복합 컴포넌트를 제공합니다
    - 의미 있는 UI 블록을 만들기 위한 기능과 엔티티의 컨테이너 역할을 합니다
  * 특성
    - 각 위젯은 자체 슬라이스입니다 (예: header, sidebar, product-card, user-profile)
    - 다른 위젯을 참조할 수 없습니다 (다른 위젯에서 코드를 가져올 수 없음)
    - 아래 레이어에서만 가져올 수 있습니다 (features, entities, shared)
    - 레이아웃 컨테이너나 자체 상태를 가진 복잡한 UI 컴포넌트 역할을 할 수 있습니다
    - UI 블록이 여러 페이지에서 재사용되거나 페이지에 여러 개의 큰 독립 블록이 있을 때 추출해야 합니다
    - 중첩 라우팅 시스템에서 라우터 블록 역할을 할 수 있으며, 평면 라우팅에서 Pages 레이어의 기능과 유사합니다
  * 주요 세그먼트
    - ui: 위젯별 컴포넌트 및 레이아웃
    - api: 위젯별 API 요청
    - model: 위젯별 상태 및 비즈니스 로직
    - lib: 위젯별 헬퍼 함수 및 유틸리티
    - config: 구성 파일 및 기능 플래그

### 1-4. Features 레이어
  * 역할
    - 애플리케이션의 주요 사용자 상호작용 및 비즈니스 프로세스를 나타냅니다
    - 사용자가 관심을 갖는 재사용 가능한 기능을 구현합니다
    - 종종 비즈니스 엔티티를 포함하는 비즈니스 로직을 캡슐화합니다
  * 특성
    - 각 기능은 자체 슬라이스입니다 (예: auth, comments, notifications, search)
    - 다른 기능을 참조할 수 없습니다 (다른 기능에서 코드를 가져올 수 없음)
    - 아래 레이어에서만 가져올 수 있습니다 (entities, shared)
    - 기능이 여러 페이지에서 재사용될 때 추출해야 합니다
    - 신규 개발자들이 부담을 느끼지 않도록 신중하게 선택해야 합니다 (모든 것이 기능일 필요는 없음)
    - 신규 개발자들이 중요한 기능 영역을 빠르게 발견하는 데 도움이 됩니다
  * 주요 세그먼트
    - ui: 양식 및 대화형 요소와 같은 기능별 UI 컴포넌트
    - api: 기능별 API 호출 및 데이터 처리
    - model: 기능별 상태, 유효성 검사 및 비즈니스 로직
    - lib: 기능별 헬퍼 함수 및 유틸리티
    - config: 기능 플래그 및 구성 설정

### 1-5. Entities 레이어
  * 역할
    - 실제 세계의 비즈니스 엔티티 및 도메인 개념을 나타냅니다
    - 애플리케이션이 작업하는 핵심 비즈니스 모델을 포함합니다
    - 비즈니스 객체의 데이터 구조 및 기본 시각화를 제공합니다
  * 특성
    - 각 엔티티는 자체 슬라이스입니다 (예: user, product, post, comment)
    - 일반적으로 비즈니스가 제품을 설명하는 데 사용하는 용어를 나타냅니다
    - 데이터 모델, 유효성 검사 스키마 및 기본 UI 표현을 포함합니다
    - shared 레이어에서만 가져올 수 있습니다
    - 슬라이스 격리를 유지하면서 엔티티 간 관계를 관리하기 위해 @x 표기법을 사용할 수 있습니다
    - UI 컴포넌트는 주로 애플리케이션 전체에서 일관된 표현을 위한 것입니다
  * 주요 세그먼트
    - ui: 일관된 시각적 표현을 위한 엔티티별 UI 컴포넌트
    - api: 엔티티별 API 요청 및 데이터 조작
    - model: 엔티티 데이터 구조, 유효성 검사 스키마 및 비즈니스 로직
    - lib: 엔티티별 헬퍼 함수 및 유틸리티
    - @x: 엔티티 관계를 관리하기 위한 교차 엔티티 가져오기

### 1-6. Shared 레이어
  * 역할
    - 나머지 애플리케이션의 기초를 형성합니다
    - 외부 세계 (백엔드, 라이브러리, 환경)와의 연결을 만듭니다
    - 재사용 가능한 유틸리티 및 핵심 기능을 제공합니다
    - 고도로 포함된, 집중된 내부 라이브러리를 정의합니다
  * 특성
    - 슬라이스를 포함하지 않습니다 (다른 중간 레이어와 달리)
    - App 레이어처럼 세그먼트로 직접 구성됩니다
    - 가장 낮은 수준의 책임과 의존성을 가집니다
    - 레이어 내의 모든 파일은 서로 참조하고 가져올 수 있습니다
    - 다른 모든 레이어에서 가져올 수 있습니다
    - 비즈니스 도메인이나 애플리케이션 특성에 의존하지 않습니다
  * 주요 세그먼트
    - api: 백엔드 엔드포인트용 API 클라이언트 및 요청 함수
    - ui: 비즈니스 로직이 없는 애플리케이션의 UI 키트 및 기본 컴포넌트
    - lib: 집중된 내부 라이브러리 (예: 날짜, 색상, 텍스트 조작)
    - config: 환경 변수, 전역 기능 플래그 및 구성
    - routes: 경로 상수 및 경로 매칭 패턴

## 2. 레이어별 가져오기 규칙

### 2-1. 간단한 요약: 코드 가져오기 규칙

FSD에서 코드를 가져오는 핵심 규칙은 다음과 같습니다:

1. **하향식 가져오기만 허용**: 항상 현재 레이어 아래의 레이어에서만 코드를 가져옵니다.
2. **수평 가져오기 금지**: 동일한 레이어 내의 다른 슬라이스에서 코드를 가져올 수 없습니다.
3. **자유로운 내부 참조**: 자신의 슬라이스 내에서 자유롭게 코드를 가져옵니다.
4. **App 및 Shared 레이어 예외**: 이 두 레이어는 슬라이스를 가지지 않으며, 해당 세그먼트는 서로 자유롭게 가져올 수 있습니다.

### 2-2. 상세 설명

#### 2-2-1. 레이어 가져오기 규칙

레이어는 슬라이스로 구성됩니다 - 고도로 응집된 모듈 그룹입니다. 슬라이스 간의 의존성은 레이어 가져오기 규칙에 의해 규제됩니다:

* 슬라이스 내의 모듈(파일)은 엄격하게 아래 레이어에 위치한 슬라이스에서만 가져올 수 있습니다.
* 예를 들어, 📁 `~/features/aaa` (`~/features/aaa/api/request.ts`) 내부의 파일은 📁 `~/features/bbb`의 어떤 파일에서도 코드를 가져올 수 없지만, 📁 `~/entities`와 📁 `~/shared`에서는 가져올 수 있습니다. 또한 자신의 슬라이스 📁 `~/features/aaa` 내의 다른 파일에서도 가져올 수 있습니다 (예: `~/features/aaa/lib/cache.ts`).

#### 2-2-2. 특별한 예외: App 및 Shared 레이어

App 및 Shared 레이어는 이 규칙의 예외입니다:
* 동시에 레이어와 슬라이스 역할을 모두 수행합니다.
* 슬라이스가 일반적으로 비즈니스 도메인에 따라 코드를 분할하는 반면, Shared는 비즈니스 도메인이 없고 App은 모든 비즈니스 도메인을 결합합니다.
* 실제로 이는 App 및 Shared 레이어가 세그먼트로 구성되어 있으며, 이러한 세그먼트는 서로 자유롭게 가져올 수 있음을 의미합니다.

#### 2-2-3. 가져오기 경로 규칙

* **동일한 슬라이스 내**: 슬라이스의 응집성과 이식성을 유지하기 위해 상대 경로가 선호됩니다. 예: features/auth 슬라이스 내에서 절대 경로 대신 `import { validatePassword } from '../lib/validators'`를 사용합니다.
* **다른 레이어에서**: 의존성을 명확하고 명시적으로 만들기 위해 다른 레이어에서 가져올 때는 절대 경로가 권장됩니다. 예: `import { User } from 'entities/user'`
* **App 및 Shared 레이어의 세그먼트에서**: 팀 선호도에 따라 상대 경로 또는 절대 경로를 사용할 수 있지만, 프로젝트 전체에서 일관성을 유지해야 합니다. 