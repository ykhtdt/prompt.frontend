Feature-Sliced Design (FSD) 아키텍처 방법론 v2.1 (한국어)

> 최신 업데이트: 2025년 05월 16일 15:40

## 목차
1. [레이어 구조](#1-레이어-구조)
2. [레이어별 가져오기 규칙](#2-레이어별-가져오기-규칙)
3. [Public API 규칙](#3-public-api-규칙)

## 1. 레이어 구조
  * 레이어는 Feature-Sliced Design의 조직적 계층 구조의 첫 번째 수준입니다.
  * 레이어의 목적은 코드가 필요로 하는 책임의 양과 앱의 다른 모듈에 대한 의존성에 따라 코드를 분리하는 것입니다.
  * 총 6개의 레이어가 있으며, 가장 높은 책임과 의존성에서 가장 낮은 순으로 정렬됩니다:

### 1-1. App 레이어
  * 역할
    - App 레이어는 Feature-Sliced Design 아키텍처의 최상위 레벨입니다.
    - 애플리케이션 초기화, 부트스트래핑 및 전역 구성을 처리합니다.
    - 애플리케이션을 실행하는 데 필요한 모든 것을 포함합니다.
  * 특성
    - 슬라이스를 포함하지 않습니다 (다른 레이어와 달리)
    - 세그먼트로 직접 구성됩니다
    - 가장 높은 수준의 책임과 의존성을 가집니다
    - 다른 모든 레이어에서 가져올 수 있습니다
    - 다른 레이어는 App 레이어에서 가져올 수 없습니다
  * 주요 세그먼트
    - providers: 전역 프로바이더 및 컨텍스트 설정
    - styles: 전역 스타일링 및 테마 구성
    - routes: 애플리케이션 라우팅 구성
    - entry: 메인 진입점 및 초기화 코드
    - fonts: 일관된 타이포그래피를 위한 전역 폰트 로딩 및 설정

### 1-2. Pages 레이어
  * 역할
    - 사용자가 직접 상호작용하는 애플리케이션의 최상위 페이지 뷰를 나타냅니다
  * 특성
    - 각 페이지는 자체 슬라이스입니다 (예: home, profile, article-read, settings)
    - 다른 페이지를 참조할 수 없습니다 (다른 페이지에서 코드를 가져올 수 없음)
    - 아래 레이어에서만 가져올 수 있습니다 (widgets, features, entities, shared)
    - 위젯, 기능 및 기타 컴포넌트를 결합하여 완전한 페이지를 만듭니다
    - 일반적으로 해당 페이지에 특정한 라우팅 구성을 포함합니다
    - 페이지별 레이아웃, 상태 관리 및 API 상호작용을 포함할 수 있습니다
  * 주요 세그먼트
    - ui: 페이지별 컴포넌트 및 레이아웃
    - api: 페이지별 API 요청
    - model: 페이지별 상태 및 비즈니스 로직
    - lib: 페이지별 헬퍼 함수 및 유틸리티
    - config: 구성 파일 및 기능 플래그

### 1-3. Widgets 레이어
  * 역할
    - 여러 페이지에서 재사용할 수 있는 크고 자급자족적인 UI 블록을 나타냅니다
    - 완전한 사용자 인터페이스 기능을 제공하는 복잡한 복합 컴포넌트를 제공합니다
    - 의미 있는 UI 블록을 만들기 위한 기능과 엔티티의 컨테이너 역할을 합니다
  * 특성
    - 각 위젯은 자체 슬라이스입니다 (예: header, sidebar, product-card, user-profile)
    - 다른 위젯을 참조할 수 없습니다 (다른 위젯에서 코드를 가져올 수 없음)
    - 아래 레이어에서만 가져올 수 있습니다 (features, entities, shared)
    - 레이아웃 컨테이너나 자체 상태를 가진 복잡한 UI 컴포넌트 역할을 할 수 있습니다
    - UI 블록이 여러 페이지에서 재사용되거나 페이지에 여러 개의 큰 독립 블록이 있을 때 추출해야 합니다
    - 중첩 라우팅 시스템에서 라우터 블록 역할을 할 수 있으며, 평면 라우팅에서 Pages 레이어의 기능과 유사합니다
  * 주요 세그먼트
    - ui: 위젯별 컴포넌트 및 레이아웃
    - api: 위젯별 API 요청
    - model: 위젯별 상태 및 비즈니스 로직
    - lib: 위젯별 헬퍼 함수 및 유틸리티
    - config: 구성 파일 및 기능 플래그

### 1-4. Features 레이어
  * 역할
    - 애플리케이션의 주요 사용자 상호작용 및 비즈니스 프로세스를 나타냅니다
    - 사용자가 관심을 갖는 재사용 가능한 기능을 구현합니다
    - 종종 비즈니스 엔티티를 포함하는 비즈니스 로직을 캡슐화합니다
  * 특성
    - 각 기능은 자체 슬라이스입니다 (예: auth, comments, notifications, search)
    - 다른 기능을 참조할 수 없습니다 (다른 기능에서 코드를 가져올 수 없음)
    - 아래 레이어에서만 가져올 수 있습니다 (entities, shared)
    - 기능이 여러 페이지에서 재사용될 때 추출해야 합니다
    - 신규 개발자들이 부담을 느끼지 않도록 신중하게 선택해야 합니다 (모든 것이 기능일 필요는 없음)
    - 신규 개발자들이 중요한 기능 영역을 빠르게 발견하는 데 도움이 됩니다
  * 주요 세그먼트
    - ui: 양식 및 대화형 요소와 같은 기능별 UI 컴포넌트
    - api: 기능별 API 호출 및 데이터 처리
    - model: 기능별 상태, 유효성 검사 및 비즈니스 로직
    - lib: 기능별 헬퍼 함수 및 유틸리티
    - config: 기능 플래그 및 구성 설정

### 1-5. Entities 레이어
  * 역할
    - 실제 세계의 비즈니스 엔티티 및 도메인 개념을 나타냅니다
    - 애플리케이션이 작업하는 핵심 비즈니스 모델을 포함합니다
    - 비즈니스 객체의 데이터 구조 및 기본 시각화를 제공합니다
  * 특성
    - 각 엔티티는 자체 슬라이스입니다 (예: user, product, post, comment)
    - 일반적으로 비즈니스가 제품을 설명하는 데 사용하는 용어를 나타냅니다
    - 데이터 모델, 유효성 검사 스키마 및 기본 UI 표현을 포함합니다
    - shared 레이어에서만 가져올 수 있습니다
    - 슬라이스 격리를 유지하면서 엔티티 간 관계를 관리하기 위해 @x 표기법을 사용할 수 있습니다
    - UI 컴포넌트는 주로 애플리케이션 전체에서 일관된 표현을 위한 것입니다
  * 주요 세그먼트
    - ui: 일관된 시각적 표현을 위한 엔티티별 UI 컴포넌트
    - api: 엔티티별 API 요청 및 데이터 조작
    - model: 엔티티 데이터 구조, 유효성 검사 스키마 및 비즈니스 로직
    - lib: 엔티티별 헬퍼 함수 및 유틸리티
    - @x: 엔티티 관계를 관리하기 위한 교차 엔티티 가져오기

### 1-6. Shared 레이어
  * 역할
    - 나머지 애플리케이션의 기초를 형성합니다
    - 외부 세계 (백엔드, 라이브러리, 환경)와의 연결을 만듭니다
    - 재사용 가능한 유틸리티 및 핵심 기능을 제공합니다
    - 고도로 포함된, 집중된 내부 라이브러리를 정의합니다
  * 특성
    - 슬라이스를 포함하지 않습니다 (다른 중간 레이어와 달리)
    - App 레이어처럼 세그먼트로 직접 구성됩니다
    - 가장 낮은 수준의 책임과 의존성을 가집니다
    - 레이어 내의 모든 파일은 서로 참조하고 가져올 수 있습니다
    - 다른 모든 레이어에서 가져올 수 있습니다
    - 비즈니스 도메인이나 애플리케이션 특성에 의존하지 않습니다
  * 주요 세그먼트
    - api: 백엔드 엔드포인트용 API 클라이언트 및 요청 함수
    - ui: 비즈니스 로직이 없는 애플리케이션의 UI 키트 및 기본 컴포넌트
    - lib: 집중된 내부 라이브러리 (예: 날짜, 색상, 텍스트 조작)
    - config: 환경 변수, 전역 기능 플래그 및 구성
    - routes: 경로 상수 및 경로 매칭 패턴

## 2. 레이어별 가져오기 규칙

### 2-1. 간단한 요약: 코드 가져오기 규칙

FSD에서 코드를 가져오는 핵심 규칙은 다음과 같습니다:

1. **하향식 가져오기만 허용**: 항상 현재 레이어 아래의 레이어에서만 코드를 가져옵니다.
2. **수평 가져오기 금지**: 동일한 레이어 내의 다른 슬라이스에서 코드를 가져올 수 없습니다.
3. **자유로운 내부 참조**: 자신의 슬라이스 내에서 자유롭게 코드를 가져옵니다.
4. **App 및 Shared 레이어 예외**: 이 두 레이어는 슬라이스를 가지지 않으며, 해당 세그먼트는 서로 자유롭게 가져올 수 있습니다.

### 2-2. 상세 설명

#### 2-2-1. 레이어 가져오기 규칙

레이어는 슬라이스로 구성됩니다 - 고도로 응집된 모듈 그룹입니다. 슬라이스 간의 의존성은 레이어 가져오기 규칙에 의해 규제됩니다:

* 슬라이스 내의 모듈(파일)은 엄격하게 아래 레이어에 위치한 슬라이스에서만 가져올 수 있습니다.
* 예를 들어, 📁 `~/features/aaa` (`~/features/aaa/api/request.ts`) 내부의 파일은 📁 `~/features/bbb`의 어떤 파일에서도 코드를 가져올 수 없지만, 📁 `~/entities`와 📁 `~/shared`에서는 가져올 수 있습니다. 또한 자신의 슬라이스 📁 `~/features/aaa` 내의 다른 파일에서도 가져올 수 있습니다 (예: `~/features/aaa/lib/cache.ts`).

#### 2-2-2. 특별한 예외: App 및 Shared 레이어

App 및 Shared 레이어는 이 규칙의 예외입니다:
* 동시에 레이어와 슬라이스 역할을 모두 수행합니다.
* 슬라이스가 일반적으로 비즈니스 도메인에 따라 코드를 분할하는 반면, Shared는 비즈니스 도메인이 없고 App은 모든 비즈니스 도메인을 결합합니다.
* 실제로 이는 App 및 Shared 레이어가 세그먼트로 구성되어 있으며, 이러한 세그먼트는 서로 자유롭게 가져올 수 있음을 의미합니다.

#### 2-2-3. 가져오기 경로 규칙

* **동일한 슬라이스 내**: 슬라이스의 응집성과 이식성을 유지하기 위해 상대 경로가 선호됩니다. 예: features/auth 슬라이스 내에서 절대 경로 대신 `import { validatePassword } from '../lib/validators'`를 사용합니다.
* **다른 레이어에서**: 의존성을 명확하고 명시적으로 만들기 위해 다른 레이어에서 가져올 때는 절대 경로가 권장됩니다. 예: `import { User } from 'entities/user'`
* **App 및 Shared 레이어의 세그먼트에서**: 팀 선호도에 따라 상대 경로 또는 절대 경로를 사용할 수 있지만, 프로젝트 전체에서 일관성을 유지해야 합니다.

#### 2-2-4. 가져오기 순서 규칙

여러 레이어에서 코드를 가져올 때는 코드의 가독성과 일관성을 유지하기 위해 다음과 같은 순서로 import 문을 작성하는 것이 권장됩니다:

* 높은 레이어에서 낮은 레이어 순으로 import 문을 배치합니다 (구체적인 것에서 추상적인 것으로).
* 예를 들어, App 레이어의 파일에서는 다음 순서로 import 문을 작성합니다:
  ```javascript
  // 1. 외부 라이브러리
  import axios from 'axios';
  
  // 2. FSD 레이어 (위에서 아래로)
  // 2.1. widgets 레이어 (app 바로 아래)
  import { Header } from 'widgets/header';
  
  // 2.2. features 레이어
  import { AuthForm } from 'features/auth';
  
  // 2.3. entities 레이어
  import { User } from 'entities/user';
  
  // 2.4. shared 레이어 (가장 아래)
  import { Button } from 'shared/ui';
  import { ApiClient } from 'shared/api';
  
  // 3. 부모 디렉토리 import
  import { config } from '../config';
  
  // 4. 현재 디렉토리 import
  import { utils } from './utils';
  ```

이러한 순서는 Feature-Sliced Design의 공식 ESLint 규칙과 일치하며, 코드의 구조와 의존성을 더 명확하게 보여줍니다.

## 3. Public API 규칙

Public API는 슬라이스와 같은 모듈 그룹과 이를 사용하는 코드 간의 계약입니다. 이를 통해, 특정 객체에만 접근할 수 있습니다.

### 3-1. Public API의 구현

실제로는 주로 재내보내기(re-exports)가 있는 인덱스 파일로 구현됩니다:

```javascript
// pages/auth/index.js
export { LoginPage } from "./ui/LoginPage";
export { RegisterPage } from "./ui/RegisterPage";
```

### 3-2. 좋은 Public API의 특성

좋은 Public API는 슬라이스의 사용과 다른 코드와의 통합을 편리하고 신뢰할 수 있게 만듭니다. 다음 세 가지 목표를 설정하여 달성할 수 있습니다:

1. 슬라이스의 구조적 변경(리팩토링 등)으로부터 애플리케이션의 나머지 부분을 보호해야 합니다.
2. 슬라이스 동작의 중요한 변경은 Public API의 변경을 유발해야 합니다.
3. 슬라이스의 필요한 부분만 노출해야 합니다.

마지막 목표는 와일드카드 재내보내기(wildcard re-exports)를 사용하지 않는 것이 중요하다는 실질적인 의미를 가집니다:

```javascript
// 나쁜 예시, features/comments/index.js
// ❌ 아래 코드는 좋지 않은 예시입니다
export * from "./ui/Comment";  // 👎 집에서 이렇게 하지 마세요
export * from "./model/comments";  // 💩 이는 나쁜 관행입니다
```

이는 슬라이스의 발견 가능성을 해치며, 실수로 모듈 내부를 노출할 수 있어 리팩토링을 어렵게 만듭니다.

### 3-3. 교차 가져오기(Cross-imports)를 위한 Public API

교차 가져오기는 같은 레이어에 있는 다른 슬라이스에서 가져오는 상황입니다. 일반적으로 레이어 가져오기 규칙에 의해 금지되지만, 정당한 이유가 있는 경우가 있습니다. 예를들어, 비즈니스 엔티티는 서로 참조하는 경우가 많기에, 이 관계를 우회하는 대신 코드에 반영하는 것이 좋습니다.

이를 위해 `@x` 표기법이라는 특별한 종류의 Public API가 있습니다. 엔티티 A와 B가 있고, 엔티티 B가 엔티티 A에서 가져와야 하는 경우, 엔티티 A는 엔티티 B만을 위한 별도의 Public API를 선언할 수 있습니다:

```
📂 entities
   📂 A
         📂 @x
                  📄 B.ts — 엔티티 B 내부 코드를 위한 특별 Public API
         📄 index.ts — 일반적인 Public API
```

그런 다음 `entities/B/` 내부의 코드는 `entities/A/@x/B`에서 가져올 수 있습니다:

```javascript
import type { EntityA } from "entities/A/@x/B";
```

`A/@x/B` 표기법은 "A crossed with B"로 읽힙니다.

> 교차 가져오기를 최소한으로 유지하고, **Entities 레이어에서만 이 표기법을 사용**하는 것이 좋습니다.

### 3-4. 인덱스 파일의 문제점

인덱스 파일(`index.js`)은 Public API를 정의하는 가장 일반적인 방법이지만, 특정 번들러와 프레임워크에서 문제를 일으킬 수 있습니다:

#### 3-4-1. 순환 가져오기(Circular imports)

순환 가져오기는 두 개 이상의 파일이 서로를 원형으로 가져올 때 발생합니다. 이는 번들러가 처리하기 어렵고 디버깅이 어려운 런타임 오류로 이어질 수 있습니다.

이 문제를 방지하기 위해 두 가지 원칙을 고려하세요:
- 같은 슬라이스 내에 있을 때는 항상 _상대_ 경로를 사용하고 전체 가져오기 경로를 작성하세요
- 다른 슬라이스에 있을 때는 항상 _절대_ 경로를 사용하세요 (예: 별칭 사용)

#### 3-4-2. Shared 레이어에서의 큰 번들과 트리 쉐이킹 문제

일부 번들러는 모든 것을 재내보내는 인덱스 파일이 있을 때 트리 쉐이킹(사용되지 않는 코드 제거)에 어려움을 겪을 수 있습니다.

일반적으로 이는 Public API에서 문제가 되지 않지만, `shared/ui`와 `shared/lib`의 경우 별도의 인덱스 파일을 각 컴포넌트나 라이브러리마다 갖는 것이 좋습니다:

```
📂 shared/ui/
   📂 button
         📄 index.js
   📂 text-field
         📄 index.js
```

#### 3-4-3. Public API 우회에 대한 보호 부재

인덱스 파일을 만들더라도 직접 가져오는 것을 금지하지는 않습니다.
**IDE의 자동 가져오기 등으로 인한 직접 가져오기로 Public API 규칙을 위반할 수 있으니 주의해야합니다.**
FSD를 위한 룰셋이 있는 Steiger와 같은 아키텍처 린터를 사용하여 이러한 문제를 자동으로 감지하는 것이 좋습니다.

#### 3-4-4. 대규모 프로젝트에서의 번들러 성능 저하

프로젝트에 많은 인덱스 파일이 있으면 개발 서버가 느려질 수 있습니다. 이 문제를 해결하기 위한 몇 가지 방법은 다음과 같습니다:

1. `shared/ui`와 `shared/lib`에서 하나의 큰 인덱스 파일 대신 각 컴포넌트/라이브러리별로 별도의 인덱스 파일을 갖습니다.
2. 슬라이스가 있는 레이어의 세그먼트에 인덱스 파일을 갖지 않습니다.
3. 매우 큰 프로젝트의 경우, 애플리케이션을 여러 큰 청크로 분할하는 것이 좋을 수 있습니다. 각 패키지는 자체 레이어 세트를 가진 별도의 FSD 루트일 수 있습니다.
  - 예를들어, 모노레포에서 일부 패키지는 Shared와 Entities 레이어만 포함할 수 있고, 다른 패키지는 Pages와 App 레이어만 가질 수 있습니다. 또는 Shared 레이어를 가지면서도 큰 패키지의 Shared 레이어를 함께 사용할 수도 있습니다.